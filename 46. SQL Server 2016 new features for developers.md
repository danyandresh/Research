# SQL Server 2016 new features for developers
## features

### 2008

- TVP
- New Date and Time types
- MERGE
- INSERT OVER DML
- GROUPING SETS
- hierarchyid
- FILESTREAM
- Geospatial
- Transparent Data Encryption (TDE)
- Chande Data Capture (CDC)
- SQL Audit

### 2012

- SQL Server Data Tools
- Windowing (OVER) enhancements
- 14 new general purpose functions
- 8 new analytic windowing functions
- Server-side paging
- Sequences
- Metadata Discovery
- FileTable
- Columnstore indexes

### 2014

- Hekaton

### 2016

- DROP IF EXISTS (DIE)
- SESSION_CONTEXT
- Dynamic Data Masking
- Row-level security (RLS)
- always encrypted
- stretch database
- temporal
- JSON
- Query Store (capture and cache execution plans)
- PolyBase (non-relational hadoop integration)
- R integration (advanced analytics with R)

## SESSION_CONTEXT

- Staful dictionary (key/value pair) object
  - Key is a Unicode string
  - Value is a sql_variant (any data type)
- Retains state for the lifetime of the connection
- Vast improvement over CONTEXT_INFO
- `sp_set_session_context`
  - system stored procedure that stores a value to session context
  - specify @key, @value and optionally @read_only
  - SESSION_CONTEXT()
    - built-in function that returns a value from session context by key

## Dynamic Data Masking (DDM)

- Full - entire column is masked
- Partial - show starting and/or ending characters of the column data, mask the rest with a custom string
- Email
- Random - entire column is replaced by random values

```sql
CREATE TABLE CUstomer(
  FirstName varchar(20)
    MASKED WITH (FUNCTION='partial(1, "...", 0)'),
  LastName varchar(20),
  Phone varchar(12)
    MASKED WITH (FUNCTION='default()'),
  Balance money
    MASKED WITH (FUNCTION='random(1000, 5000)')
)
```

```sql
ALTER TABLE Customer
  ALTER COLUMN LastName
    ADD MASKED WITH (FUNCTION='default()')
```

`sys.columns`

- `is_masked`
- `masking_function`

`sys.masked_columns`

`ALTER ANY MASK` - add replace or remove a column mask

`UNMASK` - view unmasked data in masked columns

## SQL to display users and permissions

```SQL
CREATE VIEW vwShowUsers AS
SELECT
  UserName    = pr.name,
  LoginName   = l.loginname,
  LoginType   = pr.type_desc,
  PermissionState = pe.state_desc,
  PermissionName  = pe.permission_name,
  PermissionClass = pe.class_desc,
  ObjectName  = o.name,
  ObjectType  = o.type_desc
FROM
  sys.database_principals as pr
  INNER JOIN sys.database_permissions AS pe ON pe.grantee_principal_id = pr.principal_id
  INNER JOIN sys.sysusers AS u ON u.uid = pr.principal_id
  LEFT OUTER JOIN sys.objects AS o ON o.object_id = pr.major_id
  LEFT OUTER JOIN master..syslogins AS l ON u.sid = l.sid
```

```SQL
EXECUTE AS USER = 'xulescu'

GO

REVERT
GO

GRANT UNMASK TO xulescu

GO

REVOKE UNMASK FROM xulescu

GO

GRANT SELECT ON MaskingSample TO xulescu

```

### DDM Limitations

- FILESTREAM columns
- COLUMN_SET or a sparse column that's part of a COLUMN_SET
- Computed columns
  - But will return masked data if it depends on a masked column
- Key for FULLTEXT index
- Encrypted columns (Always Encrypted)
- Once masked the actual data can never be obtained
- An ETL process from a source with masked column results in an irreversible data loss when loaded into the target environment

## Row-Level security

### Filter predicate

- SELECT, UPDATE, DELETE

### Block predicate

- ADTER INSERT, AFTER UPDATE
  - Can't insert or update rows to calues that would violate the predicate
- BEFORE UPDATE, BEFORE DELETE
  - Can't update or delete rows that violate the predicate
  - Implied when combined with filter predicate

- Inline table-valued functions (TVF)
- Accept any parameters of any type
- Examine the row via the columns passed in as parameters
- Return a scalat 1 (allow) or nothing at all (deny)
- Encapsulate logic inside WHERE clause of a single SELECT statement inside the TVF

```SQL
CREATE FUNCTION sec.fn_MySecurityPredicate(@Param1 AS int, ...)
  RETURNS TABLE
  WITH SCHEMABINDING
AS
  -- SQL Server passes in column values of each row via parameters
  RETURN
    SELECT 1 AS Result
    WHERE ...
      -- Custom logic here examines the parameters (column values)
      -- passed in, and determines the row's accessibility
```

```SQL
CREATE SECURITY POLICY sec.MySecurityPolicy
  ADD FILTER PREDICATE sec.fn_MySecurityPredicate(Col1, ...)
    ON dbo.MyTable
  WITH (STATE = ON)
```

```SQL
CREATE USER ManagerUser WITHOUT LOGIN
CREATE USER SalesUser1 WITHOUT LOGIN
CREATE USER SalesUser2 WITHOUT LOGIN

GRANT SELECT, INSERT, UPDATE, DELETE ON Sales TO ManagerUser
GRANT SELECT ON Sales TO SalesUser1
GRANT SELECT ON Sales TO SalesUser2

CREATE SCHEMA sec


CREATE FUNCTION sec.fn_securitypredicate(@Username AS varchar(50))
  RETURNS TABLE
  WITH SCHEMABINDING
AS
  RETURN
  SELECT
    1 AS fn_securitypredicate_result
  WHERE
    DATABASE_PRINCIPAL_ID() = DATABASE_PRINCIPAL_ID(@Username) OR
    DATABASE_PRINCIPAL_ID() = DATABASE_PRINCIPAL_ID('ManagerUser')

```

```SQL
CREATE SECURITY POLICY sec.SalesPolicyFilter
  ADD FILTER PREDICATE sec.fn_securitypredicate(SalesUsername)
  ON dbo.Sales
  WITH (STATE = ON)
```

```SQL
ALTER SECURITY POLICY sec.SalesPolicyFilter WITH (STATE = OFF)
```

> Use session context  to set application level user id as the DATABASE_PRINCIPAL_ID is likely to be the same for all users (application uses the same connection string)


```SQL
CREATE SECURITY POLICY sec.SalesPolicyFilter
  ADD FILTER PREDICATE sec.fn_securitypredicate(SalesUsername) ON dbo.Sales,
  ADD BLOCK PREDICATE sec.fn_securitypredicate(SalesUsername) ON dbo.Sales AFTER INSERT,
  ADD BLOCK PREDICATE sec.fn_securitypredicate(SalesUsername) ON dbo.Sales AFTER UPDATE
  WITH (STATE = ON)
```

## Always encrypted

- Based on keys managed outside the database
- Keys are never revealed to SQL server
- Uses client side drivers to encrypt and decrypt on the fly
- Data is always encrypted in flight

### Encryption Types

- Randomised
  - Unpredictable, more secure
  - No support for equality searches, joins, grouping, indexing
  - Use for data that is returned but not queried
- Deterministic
  - Predictable but less secure
  - Use for data that must be queried (equality support only)

### Encryption Keys

- Column Encryption Keys (CEK)
  - Used to encrypt values in specific columns
  - Encrypted versions of each CEK is stored in the database
- Column Master Keys (CMK)
  - Used to encrypt all the CEKs
  - Must be stored externally in a secure key store
    - Key store providers: Azure Key Vault, Certificate Store, Hardware Security Models

```
Column Encryption Setting=Enabled
```

### Catalog views

- `sys.column_master_keys`
  - Identifies each CMK
  - Contains external path to the CMK location
- `sys.column_encryption_keys`
  - Identifies each CEK
- `sys.column_encryption_key_values`
  - Contains CMK-encrypted values of each CEK
- `sys.columns`
  - New metadata columns to identify encrypted columns

### CMK Rotation

CEKs encrypt all the sensitive data
  - they are encrypted by a CMK
CMK encrypts all the CEKs
  - When the CMK is compromised, all the sensitive data is compromised

Rotate the CMK
  - Create a new CMK
  - Re-encrypt the CEKs with the new CMK
  - Powershell script available for CMK rotation
  - SSMS has GUI support


### Limitations

Unsupported data types
  - xml, rowversion, image, ntext, text, sql_variant, hierarchyid, geography, geometry
  - FILESTREAM, ROWGUIDCOL, IDENTITY, computed, sparse, or partitioning columns
  - Fulltext indexes
  - Columns with default constraints
  - Temporal tables
  - Stretch database
  - Entity framework (there are workarounds)
  - Additional management to install certificates on all clients


## Stretch database

Store portions of a database in the cloud

Remote data archive
  - Keep "hot" data in local SQL Server database (on-premises)
  - Seamlessly migrate "cold" data to Azure SQL Database

Stretch Database Advisor

`sys.sp_rda_deauthorize_db`
`sys.sp_rda_authorize_db`

 ```SQL
 EXEC sp_configure 'remote data archive', 1

 RECONFIGURE

 CREATE MASTER KEY
  ENCRYPTION BY PASSWORD = 'whatever'

CREATE DATABASE SCOPED CREDENTIAL MyStretchedDBScopedCredentialName
  WITH IDENTITY = 'lenni', SECRET = 'BigSecret!1'

ALTER DATABASE MyStretchedDB
  SET REMOTE_DATA_ARCHIVE = ON (SERVER = 'some', CREDENTIAL =  MyStretchedDBScopedCredentialName)

ALTER TABLE StretchTest
  SET (REMOTE_DATA_ARCHIVE = ON (MIGRATION_STATE = PAUSED))

SELECT * FROM sys.dm_db_rda_migration_status WHERE migrated_rows > 0

EXEC sp_spaceused @objname = 'dbo.StretchTest', @mode = 'LOCAL_ONLY'

```

Once migrated to the cloud data can't be updated or delete

Can't change schema

### Stretching selected rows

The entire table doesn't need to be stretched
  - write a predicate function to filter the rows to be migrated
  - easily filter by date, status or other constant

Filter predicate restrictions
  - Expression must be deterministic
  - Can't inherently implement a sliding window function

Update filter predicates in place
  - signature must not change
  - new function must be less restrictive than current one


### Unsuported table types

- Memory-optimised tables (Hekaton)
- Replicated tables
- FILESTREAM/FileTable
- Tables enabled fir Change Tracking or Change Data Capture

### Unsupported data types and column properties

- timestamp, sql_variant, xml, geography, geometry, hierarchyid, CLR UDTs, COLUMN_SET, computed columns

### Unsupported indexes
- XML, full-text, spatial, indexed views into the table

### Unsupported constraints

- Check constraints
- Default constraints
- Foreign key constraints out of the table (parent tables)
- Uniqueness not enforced UNIQUE constraints
- UPDATE and DELETE not supported
- ALTER TABLE not supported
- Views over stretched tables
  - Can't create index on the view
  - Can't update or delete from the view (but can insert)

## Temporal Tables

former System Version Tables

### Using temporal

Create an ordinary table

- Must have a primary key column
- Must have two period (start and end date) `datetime2` columns

Enable the table for temporal

- Creates history table with same schema, but without constraints
- Automatically records updates and deletes to the history table

Query to point in time

- Include `FOR SYSTEM_TIME AS OF` in the SELECT statement

Manage schema changes
- ALTER TABLE automatically updates the history table
  - Some schema changes require turning temporal off, applying the changes to both tables and then turning it back on

```SQL
CREATE TABLE Department
(
  DepartmentId    int NOT NULL    IDENTITY(1,1) PRIMARY KEY,
  ValidFrom       datetime2 GENERATED ALWAYS AS ROW START NOT NULL,
  ValidTo         datetime2 GENERATED ALWAYS AS ROW END   NOT NULL


WITH (SYSTEM_VERSIONING = ON (HISTORY_TABLE = dbo.DepartmentHistory))
```

```SQL
DECLARE @ThirtyDaysAgo datetime2 = DATEADD(d, -30, SYSDATETIME())

SELECT *
  FROM Department
  FOR SYSTEM_TIME AS OF @ThirtyDaysAgo  
```

```SQL
SELECT object_id,
        name,
        temporal_type,
        temporal_type_desc,
        history_table_id
FROM
  sys.tables
WHERE
  object_id = OBJECT_ID('dbo.Department', 'U') OR
  object_id = (
      SELECT history_table_id
      FROM sys.tables
      WHERE object_id = OBJECT_ID('dbo.Department', 'U')
  )
```

> Period columns can be `HIDDEN`

Adding a normal column works seamlessly, adding an identity column does not work that nicely: must break temporal and add it individually to both tables

### limitations

- triggers
  - INSTEAD OF triggers are unsupported
  - AFTER triggers are supported on the current table only
- cascading updates and deletes are not supported
- in-memory OLTP (hekaton) not supported
- FILESTREAM/FileTable not supported
- INSERT and UPDATE columns can't reference the period columns


Works with other new SQL Server 2016 features

- DDM, RLS, Always Encrypted, Stretch

## JSON

- Capabilities
  - Format and export JSON from relation queries
  - Store and query JSON inside the database
- Conceptually similar to XML support
  - Simpler model
  - No native "json" data type; uses `nvarchar(max)`
- Why no native type?
  - Easier migration to leave json columns as ordinary string types
  - Cross-feature compatibility (e.g. Hekaton, temporal)
- No custom JSON indexes
  - Optimise JSON queries using standard indexes
  - Create computed columns over desired properties, and then index the computed columns


### `FOR JSON`

- `ISJSON`
- `JSON_VALUE`
- `JSON_QUERY`
- `OPENJSON`
- `FOR JSON AUTO`
- `FOR JSON PATH`
- `WITHOUT_ARRAY_WRRAPPER`
- `ROOT`
- `INCLUDE_NULL_VALUES`

```SQL
DECLARE @jsonData AS nvarchar(max)

SET @jsonData = (SELECT
                  Customer.CustomerID,
                  Customer.AccountNumber,
                  SalesOrder.SalesOrderID,
                  SalesOrder.OrderDate
                FROM
                  Sales.Customer AS Customer
                  INNER JOIN Sales.SalesOrderHeader AS SalesOrder ON SalesOrder.CustomerID = Customer.CustomerID
                WHERE
                  Customer.CustomerID BETWEEN 11001 AND 11003
                FOR JSON AUTO)
```

### JSON PATH

```SQL
SELECT FirstName as [Contact.FirstName],
       LastName as [Contact.LastName]
FROM
  table
FOR JSON PATH
```

### json path expressions

- `$`
- `$.prop1`
- `$.prop1[2].prop3`

```SQL
SELECT JSON_VALUE(OrderDetails, '$.Order.ShipDate')
```

```SQL
CREATE TABLE T1(
  OrdersDoc nvarchar(max),
  CONSTRAINT [CK_OrdersJson_OrdersDoc] CHECK (ISJSON(OrdersDoc) = 1)
)
```

```SQL
ALTER TABLE T1
  ADD Category AS JSON_VALUE(Doc, '$.category')

CREATE INDEX IX_1
  ON T1(Category)
```

### OPENJSON

`0` - null
`1` - string
`2` - int
`3` - bool
`4` - array
`5` - object

```SQL
SELECT *
  FROM OPENJSON(@json, '$.Order')
  WITH (
    OrderNumber varchar(200),
    OrderDate   datetime,
    Customer    varchar(200)  '$.AccountNumber',
    Item        nvarchar(max) '$.Item' as JSON
  )
```
